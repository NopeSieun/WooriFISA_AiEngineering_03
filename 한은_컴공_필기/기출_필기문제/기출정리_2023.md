# 소프트웨어 공학과 관련하여 다음 물음에 답하시오.

## 1. 작업 네트워크의 임계경로(critical path)가 무엇인지 서술하시오.

임계경로(Critical Path)는 프로젝트 관리에서 전체 프로젝트의 완료 시간을 결정하는 가장 긴 경로를 의미합니다. 작업 네트워크에서 임계경로는 시작 노드에서 종료 노드까지 이어지는 경로들 중에서 가장 오랜 시간이 걸리는 경로입니다. 이 경로에 포함된 작업들은 여유 시간이 없으며, 이 작업들 중 하나라도 지연될 경우, 전체 프로젝트의 완료 시점이 지연됩니다.

임계경로는 프로젝트의 최단 완료 시간을 결정하는 데 중요한 요소로, 프로젝트 관리자는 이 경로상의 작업들을 특히 주의 깊게 관리해야 합니다. 임계경로를 파악하면 프로젝트 내에서 시간 관리를 효율적으로 할 수 있고, 중요한 작업의 지연을 방지하여 전체 프로젝트 일정을 준수할 수 있습니다.

# 자료구조와 관련하여 다음 물음에 답하시오.

## 1. 깊이우선탐색(DFS, Depth First Search)과 너비우선탐색(BFS, Breadth First Search)의 개념을 각각 설명하고, 각 탐색 방법의 구현에 가장 적합한 자료구조 형식을 제시하시오.

### 깊이우선탐색(DFS, Depth First Search)

**개념**:
깊이우선탐색(DFS)은 그래프나 트리 구조에서 출발 노드(루트)에서 시작하여 한 갈래로 최대한 깊이 내려간 후, 더 이상 내려갈 수 없으면 다시 위로 올라가 다음 갈래를 탐색하는 방식입니다. DFS는 재귀적으로 깊이 들어가며, 그래프의 모든 노드를 방문할 때까지 이 과정을 반복합니다. DFS는 특정 경로에 대한 탐색이 필요한 경우, 또는 모든 가능한 경로를 탐색하는 데 적합합니다.

**적합한 자료구조**:

- **스택(Stack)**: DFS는 후입선출(LIFO) 원칙을 따르는 스택을 이용하여 구현하는 것이 적합합니다. 재귀적으로 탐색을 수행할 때, 호출 스택(call stack)을 자연스럽게 활용할 수도 있습니다.
- **재귀 함수**: DFS는 재귀 함수를 통해 구현할 수 있으며, 이 경우 호출 스택이 자연스럽게 스택 역할을 수행합니다.

### 너비우선탐색(BFS, Breadth First Search)

**개념**:
너비우선탐색(BFS)은 그래프나 트리 구조에서 출발 노드(루트)에서 시작하여 인접한 모든 노드를 우선적으로 탐색한 후, 다음 레벨로 넘어가 다시 인접한 모든 노드를 탐색하는 방식입니다. BFS는 레벨 단위로 탐색을 진행하며, 특정 노드에서 가장 가까운 경로를 찾는 데 유용합니다. BFS는 최단 경로를 찾는 문제에 특히 적합합니다.

**적합한 자료구조**:

- **큐(Queue)**: BFS는 선입선출(FIFO) 원칙을 따르는 큐를 이용하여 구현하는 것이 적합합니다. 현재 노드의 인접 노드들을 모두 큐에 넣고, 큐에서 노드를 하나씩 꺼내어 탐색하는 방식으로 진행됩니다.

### 요약

- **깊이우선탐색(DFS)**는 그래프나 트리의 한 갈래를 최대한 깊이 탐색한 후, 다른 갈래를 탐색하는 방식이며, **스택**을 이용하여 구현하는 것이 적합합니다. 재귀 호출을 사용하여 구현할 수도 있습니다.
- **너비우선탐색(BFS)**는 그래프나 트리에서 각 레벨을 순차적으로 탐색하는 방식이며, **큐**를 이용하여 구현하는 것이 적합합니다. BFS는 최단 경로 탐색에 유리합니다.

# 네트워크와 관련하여 다음 물음에 답하시오.

## 1. 동적 호스트 구성 프로토콜(DHCP, Dynamic Host Configuration Protocol)의 간단한 동작시나리오가 있을 때, 동적 호스트 구성 프로토콜(DHCP)에 대해 설명하시오.

동적 호스트 구성 프로토콜(DHCP, Dynamic Host Configuration Protocol)은 네트워크에서 IP 주소를 비롯한 네트워크 설정 정보를 자동으로 할당하는 프로토콜입니다. DHCP를 통해 네트워크에 연결된 장치들은 수동으로 IP 주소를 설정할 필요 없이, 자동으로 IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 등의 설정을 받을 수 있습니다. DHCP는 네트워크 관리의 효율성을 높이고, IP 주소 충돌을 방지하며, 사용자가 네트워크 설정을 직접 관리하지 않아도 되는 편리함을 제공합니다.

DHCP의 동작 과정은 크게 네 가지 단계로 이루어집니다:

- 클라이언트가 네트워크에 연결되면 `DHCPDISCOVER` 메시지를 브로드캐스트하여 자신에게 IP 주소를 할당할 DHCP 서버를 찾습니다.
- DHCP 서버들은 이에 응답하여 `DHCPOFFER` 메시지를 보내, 할당 가능한 IP 주소와 네트워크 설정 정보를 제안합니다.
- 클라이언트는 제안된 IP 주소 중 하나를 선택하고, `DHCPREQUEST` 메시지로 해당 서버에 요청을 확정합니다.
- 최종적으로 DHCP 서버는 `DHCPACK` 메시지를 보내, 클라이언트가 선택한 IP 주소와 네트워크 설정 정보를 할당합니다.

이 과정을 통해 클라이언트는 네트워크 설정을 자동으로 할당받아 네트워크에 연결됩니다.

## 2. DISCOVER, OFFER, REQUEST, ACK 4단계에서 브로드캐스팅을 하는 이유를 각각 설명하시오.

**DHCPDISCOVER 단계에서의 브로드캐스트:**

DHCP 클라이언트는 처음 네트워크에 연결될 때, 아직 IP 주소를 할당받지 않았기 때문에 특정 DHCP 서버에 직접 메시지를 보낼 수 없습니다. 따라서 네트워크 상의 모든 DHCP 서버에게 자신의 존재를 알리기 위해 브로드캐스트를 사용합니다. 이 방식으로 모든 DHCP 서버가 DISCOVER 메시지를 수신할 수 있습니다.

**DHCPOFFER 단계에서의 브로드캐스트:**

여러 DHCP 서버가 동일한 클라이언트에게 응답할 수 있으므로, DHCPOFFER 메시지도 브로드캐스트로 전송됩니다. 이는 클라이언트가 IP 주소를 할당받기 전에는 자신의 IP 주소가 없기 때문에, 특정 클라이언트를 지정해 메시지를 전송할 수 없기 때문입니다. 따라서 브로드캐스트를 사용하여 클라이언트에게 메시지를 전달합니다.

**DHCPREQUEST 단계에서의 브로드캐스트:**

클라이언트는 여러 DHCP 서버 중 하나의 제안을 수락할 때, 해당 서버뿐만 아니라 네트워크에 있는 다른 DHCP 서버들에게도 자신의 선택을 알리기 위해 브로드캐스트를 사용합니다. 이는 선택되지 않은 DHCP 서버가 제안한 IP 주소를 다시 사용할 수 있도록 하기 위함입니다.

**DHCPACK 단계에서의 브로드캐스트:**

DHCPACK 메시지는 선택된 DHCP 서버가 클라이언트에게 IP 주소 할당을 확정지어주는 단계입니다. 이 단계에서 브로드캐스트를 사용하는 이유는 클라이언트가 아직 최종 IP 주소를 확정받기 전이기 때문에 특정 IP 주소로 메시지를 직접 보내는 것이 불가능할 수 있기 때문입니다. 또한 네트워크에 있는 다른 장치들이 클라이언트의 IP 주소를 인지하도록 하기 위해 브로드캐스트를 사용할 수도 있습니다.

## 3. 210.11.21.0/24의 주소 블록을 할당받은 기관이 있다. 이 기관은 각각 100개, 50개, 10개의 호스트 를 사용할 수 있도록 3개의 서브블록을 효율적으로 구성하려고 한다. 다음 물음에 답하시오.

### a. 각 서브블록의 서브넷마스크를 구하시오.

1. **호스트 수에 따른 서브넷마스크 결정**:

   - 서브넷의 크기는 호스트 수에 따라 결정됩니다. 각 서브넷에는 2^n - 2개의 호스트를 수용할 수 있으며, 여기서 n은 호스트 부분의 비트 수입니다. `-2`는 네트워크 주소와 브로드캐스트 주소를 제외하기 때문입니다.

2. **100개의 호스트를 수용할 수 있는 서브넷**:

   - 호스트 수를 수용할 수 있는 최소 비트 수는 다음과 같습니다:
     - 2^n - 2 ≥ 100 → 2^n ≥ 102 → n = 7 (즉, 7비트가 필요)
   - 서브넷마스크: 호스트 부분이 7비트이므로, 네트워크 부분은 32비트 - 7비트 = 25비트
   - 서브넷마스크: **/25 또는 255.255.255.128**

3. **50개의 호스트를 수용할 수 있는 서브넷**:

   - 호스트 수를 수용할 수 있는 최소 비트 수는 다음과 같습니다:
     - 2^n - 2 ≥ 50 → 2^n ≥ 52 → n = 6 (즉, 6비트가 필요)
   - 서브넷마스크: 호스트 부분이 6비트이므로, 네트워크 부분은 32비트 - 6비트 = 26비트
   - 서브넷마스크: **/26 또는 255.255.255.192**

4. **10개의 호스트를 수용할 수 있는 서브넷**:
   - 호스트 수를 수용할 수 있는 최소 비트 수는 다음과 같습니다:
     - 2^n - 2 ≥ 10 → 2^n ≥ 12 → n = 4 (즉, 4비트가 필요)
   - 서브넷마스크: 호스트 부분이 4비트이므로, 네트워크 부분은 32비트 - 4비트 = 28비트
   - 서브넷마스크: **/28 또는 255.255.255.240**

- **100개의 호스트를 수용할 수 있는 서브블록**: 서브넷마스크 **/25 또는 255.255.255.128**
- **50개의 호스트를 수용할 수 있는 서브블록**: 서브넷마스크 **/26 또는 255.255.255.192**
- **10개의 호스트를 수용할 수 있는 서브블록**: 서브넷마스크 **/28 또는 255.255.255.240**

### b. 각 서브블록의 첫 번째 IP주소를 구하시오.

**210.11.21.0/24** 블록에서 서브넷 마스크는 각 서브블록의 크기에 따라 다르게 설정됩니다.

- **서브블록 1 (100개 호스트)**: /25 서브넷마스크, 128개 주소 (210.11.21.0 ~ 210.11.21.127)
- **서브블록 2 (50개 호스트)**: /26 서브넷마스크, 64개 주소 (210.11.21.128 ~ 210.11.21.191)
- **서브블록 3 (10개 호스트)**: /28 서브넷마스크, 16개 주소 (210.11.21.192 ~ 210.11.21.207)

**각 서브블록의 첫 번째 IP 주소**

1. **서브블록 1 (100개 호스트)**

   - 서브넷마스크: /25 (255.255.255.128)
   - 범위: 210.11.21.0 ~ 210.11.21.127
   - **첫 번째 IP 주소**: **210.11.21.0**

2. **서브블록 2 (50개 호스트)**

   - 서브넷마스크: /26 (255.255.255.192)
   - 범위: 210.11.21.128 ~ 210.11.21.191
   - **첫 번째 IP 주소**: **210.11.21.128**

3. **서브블록 3 (10개 호스트)**
   - 서브넷마스크: /28 (255.255.255.240)
   - 범위: 210.11.21.192 ~ 210.11.21.207
   - **첫 번째 IP 주소**: **210.11.21.192**

**답변 요약**

- **서브블록 1**의 첫 번째 IP 주소: **210.11.21.0**
- **서브블록 2**의 첫 번째 IP 주소: **210.11.21.128**
- **서브블록 3**의 첫 번째 IP 주소: **210.11.21.192**

### c. 각 서브블록의 사용 가능한 호스트 개수를 구하시오.

**서브블록 1 (100개 호스트)**

- **서브넷마스크**: /25 (255.255.255.128)
- **서브넷 크기**: 2^(32 - 25) = 2^7 = 128개 IP 주소
- **사용 가능한 호스트 수**: 128 - 2 = **126개**  
  (네트워크 주소와 브로드캐스트 주소를 제외한 126개의 호스트 주소가 사용 가능)

**서브블록 2 (50개 호스트)**

- **서브넷마스크**: /26 (255.255.255.192)
- **서브넷 크기**: 2^(32 - 26) = 2^6 = 64개 IP 주소
- **사용 가능한 호스트 수**: 64 - 2 = **62개**  
  (네트워크 주소와 브로드캐스트 주소를 제외한 62개의 호스트 주소가 사용 가능)

**서브블록 3 (10개 호스트)**

- **서브넷마스크**: /28 (255.255.255.240)
- **서브넷 크기**: 2^(32 - 28) = 2^4 = 16개 IP 주소
- **사용 가능한 호스트 수**: 16 - 2 = **14개**  
  (네트워크 주소와 브로드캐스트 주소를 제외한 14개의 호스트 주소가 사용 가능)

## 4. 네트워크의 성능은 지연(delay), 처리량(throughput), 패킷 손실률(packet loss)로 측정할 수 있다. 네트워크상 지연의 4가지 형태인 전송 지연, 전파 지연, 처리 지연, 큐잉 지연에 대해 각각 설명하시오.

네트워크에서 지연(delay)은 데이터 패킷이 출발지에서 목적지까지 도달하는 데 걸리는 시간을 의미하며, 네트워크 성능을 평가하는 중요한 요소입니다. 지연에는 여러 유형이 있으며, 각 유형은 네트워크의 다른 부분에서 발생합니다. 대표적인 지연의 형태로는 전송 지연, 전파 지연, 처리 지연, 큐잉 지연이 있습니다.

### 전송 지연 (Transmission Delay)

전송 지연은 네트워크에서 데이터를 전송 매체로 보내는 데 걸리는 시간입니다. 이는 데이터를 비트 단위로 전송하기 위해 필요한 시간으로, 주로 데이터의 크기와 네트워크 링크의 전송 속도에 영향을 받습니다. 쉽게 말해, 데이터를 네트워크에 "밀어 넣는" 과정에서 발생하는 지연입니다.

### 전파 지연 (Propagation Delay)

전파 지연은 신호가 전송 매체를 통해 이동하는 데 걸리는 시간입니다. 이는 네트워크의 물리적 거리와 신호가 매체를 통해 전파되는 속도에 따라 달라집니다. 예를 들어, 두 지점 간의 거리가 멀수록 신호가 도달하는 데 시간이 더 오래 걸리며, 이는 전파 지연을 증가시킵니다.

### 처리 지연 (Processing Delay)

처리 지연은 라우터나 스위치와 같은 네트워크 장치가 수신한 패킷을 처리하는 데 걸리는 시간입니다. 이 과정에는 패킷의 헤더를 분석하고, 다음 목적지를 결정하는 작업이 포함됩니다. 네트워크 장치의 성능과 처리 복잡성에 따라 처리 지연이 발생합니다.

### 큐잉 지연 (Queuing Delay)

큐잉 지연은 패킷이 네트워크 장치에서 처리되기 전에 대기열에서 기다리는 시간입니다. 네트워크 트래픽이 많을 때, 여러 패킷이 동시에 도착하면 장치의 대기열에서 대기하게 되며, 이로 인해 지연이 발생합니다. 트래픽이 혼잡할수록 큐잉 지연이 길어질 수 있습니다.

## 5. 파일 전송 프로토콜(FTP, File Transfer Protocol)은 하나의 호스트에서 다른 호스트로 파일을 복사하기 위해 TCP/IP에 의해 제공되는 표준 기능이다. FTP는 효율적인 사용을 위해 호스트 간에 두 개의 채널(데이터 전송, 제어)을 연결한다. 아래의 FTP 명령어 예제를 참고하여 다음 물음에 답하시오.

```
USER, PORT, RETR, PASV, PASS, STOR
```

### a. FTP는 암호화되지 않은 평문으로 데이터를 전송하고 있어 이를 공격자가 가로채어 사용할 수 있기 때문에 보안에 취약하다. 데이터 탈취를 막기 위해 SFTP나 FTPS를 사용하는데 이에 대해 각각 설명하시오.

##### SFTP (Secure File Transfer Protocol)

**SFTP**는 **SSH 파일 전송 프로토콜(Secure Shell File Transfer Protocol)**의 약자로, SSH(보안 셸) 프로토콜을 통해 파일 전송을 안전하게 수행하는 방식입니다. SFTP는 FTP와 달리 데이터 전송뿐만 아니라 명령어 전송도 모두 암호화하여 전송합니다. 이는 네트워크에서 전송 중인 데이터를 보호하고, 중간에 제3자가 데이터를 가로채더라도 이를 이해하거나 변조할 수 없도록 보장합니다. SFTP는 하나의 연결을 통해 명령어와 데이터를 모두 처리하며, 기본적으로 SSH 프로토콜을 사용하기 때문에 별도의 데이터 채널을 개설할 필요가 없습니다. SFTP는 보안이 중요한 환경에서 널리 사용됩니다.

##### FTPS (FTP Secure or FTP-SSL)

**FTPS**는 **FTP Secure** 또는 **FTP-SSL**로 불리며, 기존의 FTP에 SSL/TLS(보안 소켓 계층/전송 계층 보안) 암호화 기능을 추가한 방식입니다. FTPS는 FTP의 기능을 유지하면서 데이터 전송 과정에서 SSL/TLS를 통해 데이터를 암호화하여 전송합니다. FTPS는 두 가지 모드로 운영될 수 있습니다:

- **명시적 모드(Explicit Mode)**: 클라이언트가 서버에 연결을 시도할 때, SSL/TLS 암호화를 요구하는 명령을 명시적으로 보냅니다. 서버는 이에 응답하여 암호화된 통신을 설정합니다.
- **암시적 모드(Implicit Mode)**: 클라이언트가 서버에 연결할 때, 기본적으로 SSL/TLS 암호화가 사용됩니다. 암호화는 클라이언트와 서버 간의 통신에서 자동으로 적용됩니다.

FTPS는 FTP와 유사한 명령어와 구조를 유지하며, 데이터와 제어 채널을 분리하여 각각 암호화할 수 있습니다. 이로 인해 기존의 FTP 시스템을 사용하는 환경에서 보안을 강화하는 데 적합합니다.

##### 요약

- **SFTP**는 SSH 프로토콜을 기반으로 모든 전송 데이터를 암호화하며, 하나의 연결에서 명령어와 데이터를 안전하게 처리합니다.
- **FTPS**는 기존 FTP에 SSL/TLS 암호화를 추가하여 데이터를 안전하게 전송하며, 명시적 모드와 암시적 모드로 운영될 수 있습니다.

### b. FTP 능동 모드를 사용할 경우 예상되는 보안 취약점에 대해 서술하고 해결 방안에 대해 작성하시오.

##### FTP 능동 모드의 보안 취약점

**FTP 능동 모드(Active Mode)**는 클라이언트가 서버에 연결을 요청할 때, 제어 채널(통상 포트 21)을 통해 명령어를 전송하고, 서버가 클라이언트의 포트(1024 이상)를 향해 데이터 채널(통상 포트 20)을 통해 역으로 연결을 시도하는 방식입니다. 이 모드에서 발생할 수 있는 주요 보안 취약점은 다음과 같습니다:

1. **방화벽 문제**: 클라이언트가 서버에게 데이터 전송을 위해 포트를 열어두고 기다려야 하므로, 클라이언트 측 방화벽이 외부에서 들어오는 연결 요청(서버가 데이터 채널을 열기 위한 시도)을 허용해야 합니다. 이로 인해 방화벽 설정이 복잡해지며, 외부에서 클라이언트로의 임의의 연결 시도를 허용하게 되어, 보안 위험이 증가합니다. 특히, 클라이언트가 허용하지 않은 외부 연결 시도를 방화벽이 필터링하지 못하면, 공격자가 임의의 데이터 전송을 시도할 수 있습니다.

2. **포트 스캐닝 및 공격 가능성**: 능동 모드에서는 서버가 클라이언트의 임의의 포트로 연결을 시도하기 때문에, 공격자가 이 과정을 악용하여 클라이언트의 열려 있는 포트를 스캔하거나, 임의의 포트에 접근해 공격을 시도할 수 있습니다. 이는 보안 취약점으로 이어질 수 있습니다.

3. **IP 스푸핑 공격**: 서버가 클라이언트가 요청한 포트로 직접 연결을 시도하기 때문에, 공격자가 클라이언트의 IP 주소를 스푸핑하여 서버로부터 데이터를 탈취하거나, 악의적인 데이터를 클라이언트로 전송할 수 있는 가능성이 있습니다.

##### 해결 방안

능동 모드에서 발생할 수 있는 이러한 보안 취약점을 해결하기 위한 방법은 다음과 같습니다:

1. **수동 모드(Passive Mode)로 전환**: FTP를 수동 모드로 전환하면, 클라이언트가 데이터 전송을 위해 서버로 연결을 시도하므로, 클라이언트가 외부에서 들어오는 연결을 허용할 필요가 없어집니다. 수동 모드에서는 서버가 데이터 채널을 열고, 클라이언트가 이 채널로 연결을 시도하기 때문에 방화벽 문제를 최소화할 수 있습니다. 이로 인해 클라이언트 측의 방화벽 설정이 단순해지고, 보안이 강화됩니다.

2. **방화벽 및 NAT 설정 최적화**: 클라이언트가 능동 모드를 사용해야 하는 경우, 방화벽이나 NAT(Network Address Translation) 장비를 통해 특정 포트만을 열고, 나머지 포트를 차단하는 방식으로 방화벽 규칙을 설정할 수 있습니다. 이를 통해 외부의 임의의 연결 시도를 차단하고, 보안 위험을 줄일 수 있습니다.

3. **FTP over SSL/TLS 사용**: FTP의 모든 전송 데이터를 암호화하는 FTPS(FTP Secure)를 사용하면, 능동 모드에서도 데이터의 무결성과 기밀성을 보장할 수 있습니다. SSL/TLS를 통해 클라이언트와 서버 간의 통신을 보호하고, 중간에 공격자가 데이터를 가로채거나 변조하는 것을 방지할 수 있습니다.

4. **정확한 IP 주소 검증 및 필터링**: 서버와 클라이언트 간에 정확한 IP 주소 검증 및 필터링을 수행하여, IP 스푸핑 공격을 방지할 수 있습니다. 클라이언트 측 방화벽은 서버의 IP 주소와 포트 번호를 정확히 확인하고, 이와 일치하는 요청만 허용하도록 설정해야 합니다.

##### 요약

FTP 능동 모드는 방화벽 문제, 포트 스캐닝, IP 스푸핑과 같은 보안 취약점을 야기할 수 있습니다. 이를 해결하기 위해 FTP 수동 모드를 사용하는 것이 일반적인 방법이며, 필요에 따라 방화벽 규칙 최적화, FTPS 사용, IP 주소 필터링 등을 통해 보안을 강화할 수 있습니다. 이러한 대책을 통해 FTP 사용 시 발생할 수 있는 보안 위험을 최소화할 수 있습니다.

# 운영체제와 관련하여 다음 물음에 답하시오.

## 1. 가상 메모리를 사용하기 위해서는 MMU(Memory Management Unit)라는 하드웨어가 필요하다. MMU의 역할과 가상 메모리를 사용했을 때의 이점을 서술하시오.

### MMU의 역할

**MMU(Memory Management Unit)**는 가상 주소를 물리적 주소로 변환하는 하드웨어 장치로, 가상 메모리 시스템에서 핵심적인 역할을 합니다. MMU는 주소 변환을 통해 프로그램이 사용하는 가상 주소를 실제 물리적 메모리 주소로 매핑하고, 프로세스 간 메모리 보호를 제공하며, 페이지 테이블을 관리하여 메모리의 효율적인 사용을 지원합니다. 또한, 페이지 부재 발생 시 이를 운영체제에 알리는 역할도 수행합니다.

### 가상 메모리의 이점

**가상 메모리**는 물리적 메모리보다 더 큰 메모리 공간을 사용할 수 있게 해주는 기법입니다. 이를 통해 다음과 같은 이점을 제공합니다:

- **효율적인 메모리 사용**: 실제로 필요한 데이터만 메모리에 적재하여 메모리 자원을 최적화합니다.
- **메모리 공간 확장**: 물리적 메모리 크기에 구애받지 않고 큰 메모리 공간을 사용할 수 있습니다.
- **프로세스 간 메모리 보호**: 각 프로세스에 독립된 메모리 공간을 할당하여 안전성을 보장합니다.
- **스왑 기능 지원**: 필요하지 않은 데이터를 디스크로 옮겨 메모리 효율성을 높입니다.

## 2. 메모리를 자유로운 크기로 할당받는 세그먼트 기법을 이용하면 외부 단편화(external fragmentation) 문제가 발생할 수 있다. 이를 해결하기 위해 메모리를 일정한 크기(예: 4KB)로 할당받는 페이징 기법을 사용하면 내부 단편화(internal fragmentation) 문제가 발생할 수 있다. 세그먼트 기법에서 발생하는 외부 단편화 문제와 페이징 기법에서 발생하는 내부 단편화 문제에 대해 각각 서술하시오.

### 외부 단편화 (External Fragmentation) - 세그먼트 기법

세그먼트 기법에서는 메모리를 프로그램이 필요로 하는 다양한 크기의 세그먼트로 나누어 할당합니다. 시간이 지나면서 세그먼트들이 할당되고 해제되면서, 사용되지 않는 작은 메모리 조각들이 여기저기 흩어지게 됩니다. 이러한 흩어진 조각들로 인해 충분한 총 메모리가 있음에도 불구하고, 새로운 세그먼트를 할당할 수 있는 연속적인 큰 메모리 공간을 찾기 어려워지는 현상을 **외부 단편화**라고 합니다. 외부 단편화는 메모리의 효율적인 사용을 저해하여, 메모리 공간의 낭비를 초래할 수 있습니다.

### 내부 단편화 (Internal Fragmentation) - 페이징 기법

페이징 기법에서는 메모리를 고정된 크기(예: 4KB)의 페이지로 나누어 할당합니다. 이때 프로그램이 요청한 메모리 크기가 페이지 크기보다 작거나 정확히 일치하지 않으면, 마지막 페이지에 남는 공간이 발생하게 됩니다. 이러한 남는 공간을 사용할 수 없게 되어 메모리 낭비가 발생하는 현상을 **내부 단편화**라고 합니다. 내부 단편화는 각 페이지 내의 사용되지 않는 공간 때문에 전체 메모리 사용 효율을 떨어뜨릴 수 있습니다.

## 3. 시스템 교착 상태(deadlock)가 발생하기 위해 동시에 성립해야 하는 조건 네 가지를 기술하시오.

시스템 교착 상태(Deadlock)가 발생하기 위해서는 다음 네 가지 조건이 동시에 성립해야 합니다:

**상호 배제(Mutual Exclusion)**: 자원은 한 번에 한 프로세스만 사용할 수 있습니다. 즉, 자원이 배타적으로 할당되어야 합니다.

**점유 대기(Hold and Wait)**: 프로세스가 이미 할당된 자원을 점유한 상태에서, 추가적인 자원을 요청하며 대기해야 합니다.

**비선점(No Preemption)**: 프로세스에 할당된 자원은 그 프로세스가 자발적으로 해제할 때까지 강제로 빼앗을 수 없습니다.

**순환 대기(Circular Wait)**: 자원 대기 상태에 있는 프로세스들이 서로 순환 형태로 자원을 대기하고 있어야 합니다. 즉, P1이 P2의 자원을 기다리고, P2는 P3의 자원을 기다리며, P3는 다시 P1의 자원을 기다리는 상태입니다.

이 네 가지 조건이 동시에 성립하면 시스템에 교착 상태가 발생할 수 있습니다.

## 4. 가상화(virtualization)란 물리적으로 분산된 시스템을 논리적으로 통합하거나 하나의 시스템을 논리 적으로 분할하여 자원을 효율적으로 사용하는 기술이다. 하이퍼바이저(hypervisor)를 이용한 서버 가상화 기술이 널리 사용되고 있으며, 최근에는 도커(docker) 등과 같이 컨테이너(container)를 통해 가상환경을 구성하는 사례도 증가하고 있다. 하이퍼바이저와 컨테이너의 차이점을 설명하시오.

**하이퍼바이저(Hypervisor)**는 물리적 하드웨어 위에서 다수의 운영체제를 실행할 수 있도록 하는 가상화 기술입니다. 하이퍼바이저는 물리적 서버를 논리적으로 분할하여 각 가상 머신(VM)마다 독립된 운영체제를 설치하고, 이를 통해 자원을 효율적으로 사용합니다. 하이퍼바이저에는 호스트형(Type 2)과 네이티브형(Type 1)이 있으며, 각 VM은 자체 운영체제를 포함하여 격리된 환경에서 실행됩니다.

**컨테이너(Container)**는 운영체제 수준의 가상화 기술로, 호스트 운영체제 위에서 애플리케이션과 그 의존성만을 분리하여 실행합니다. 컨테이너는 하이퍼바이저와 달리 개별 운영체제를 포함하지 않으며, 호스트 운영체제의 커널을 공유합니다. 이는 컨테이너가 더 가볍고 빠르며, 자원 효율성이 높은 이유입니다. 도커(Docker)는 이러한 컨테이너 기반 가상화 기술의 대표적인 플랫폼입니다.

### 요약

- **하이퍼바이저**는 물리적 서버를 논리적으로 분할하여 각 가상 머신이 독립된 운영체제에서 실행되도록 하는 반면,
- **컨테이너**는 운영체제의 커널을 공유하며 애플리케이션을 격리된 환경에서 실행하여 더 가볍고 빠른 가상화를 제공합니다.

# 머신러닝과 관련하여 다음 물음에 답하시오.

## 1. 학습률, (learning rate)가 너무 크거나 작을 때 발생할 수 있는 문제점에 대해 각각 서술하시오.

### 학습률이 너무 클 때

- **수렴 실패**: 학습률이 너무 크면 가중치 업데이트가 과도하게 이루어져 손실 함수가 발산하거나 최적해를 지나쳐 학습이 수렴하지 않을 수 있습니다.
- **불안정한 학습**: 모델이 최적해를 반복적으로 지나치면서 손실 값이 진동하거나, 최적화가 이루어지지 않아 학습이 불안정해질 수 있습니다.

### 학습률이 너무 작을 때

- **느린 학습**: 학습률이 너무 작으면 가중치 업데이트가 매우 느리게 진행되어 학습 속도가 저하되며, 모델이 수렴하는 데 오랜 시간이 걸립니다.
- **지역 최적해에 갇힘**: 너무 작은 학습률은 모델이 손실 함수의 복잡한 표면을 탐색하지 못하고, 지역 최적해에 빠질 위험을 증가시킵니다.

## 2. 국소 최솟값(local minimum)에 빠져 전 역 최솟값을 찾지 못할 수 있다. 전역 최솟값 발견 확률을 높일 수 있는 방법을 제시하시오.

**적절한 학습률 설정**: 학습률을 적절하게 조절하거나 학습률 감소(learning rate decay) 또는 적응형 학습률(adaptive learning rate) 기법을 사용하면, 최적화 과정에서 국소 최솟값에 갇힐 가능성을 줄일 수 있습니다.

**모멘텀(Momentum) 사용**: 모멘텀 기법을 사용하면 이전 업데이트 방향을 고려하여 가중치를 조정함으로써 국소 최솟값을 탈출하고 전역 최솟값으로 접근할 가능성을 높입니다.

**배치 정규화(Batch Normalization)**: 배치 정규화를 사용하면 각 배치의 분포를 정규화하여 학습 과정의 안정성을 높이고, 전역 최솟값으로 수렴할 가능성을 증가시킬 수 있습니다.

**다양한 초기화(Weight Initialization)**: 가중치를 다양한 값으로 초기화하여 여러 번 학습을 시도하면, 국소 최솟값에 빠질 가능성을 줄이고 전역 최솟값을 찾을 확률을 높일 수 있습니다.

**심층 신경망에서 드롭아웃(Dropout) 사용**: 드롭아웃은 과적합을 방지하면서 모델이 더 다양한 경로를 탐색하도록 하여, 국소 최솟값에 갇힐 위험을 줄입니다.

## 3. 머신러닝에서 발생할 수 있는 과잉 적합(overfitting)과 과소 적합(underfitting)에 대해 서술하시오.

### 과잉 적합(Overfitting)

- **정의**: 과잉 적합은 모델이 학습 데이터에 지나치게 맞춰져, 학습 데이터에서는 높은 성능을 보이지만 새로운 데이터(테스트 데이터)에서는 일반화 능력이 떨어지는 현상입니다. 이는 모델이 학습 데이터의 노이즈나 세부적인 패턴까지 학습한 결과로, 복잡한 모델에서 자주 발생합니다.

### 과소 적합(Underfitting)

- **정의**: 과소 적합은 모델이 학습 데이터의 패턴을 충분히 학습하지 못해, 학습 데이터와 테스트 데이터 모두에서 성능이 낮은 현상입니다. 이는 모델이 너무 단순하거나 학습이 충분하지 않아, 데이터의 복잡한 패턴을 포착하지 못할 때 발생합니다.

## 4. 인공 신경망은 생물학적 뉴런을 기반으로 만들어낸 수학적 모델인 퍼셉트론(perceptron)을 사용하며 활성화 함수로 비선형 함수인 ReLU를 사용한다.

### a. 퍼셉트론의 동작 원리에 대해 간단히 설명하시오.

퍼셉트론은 인공 신경망의 기본 단위로, 입력 값에 가중치를 곱한 후 그 합을 계산하여, 활성화 함수를 통해 최종 출력을 결정하는 모델입니다. 입력 값과 가중치의 선형 결합을 구한 뒤, 이를 활성화 함수에 입력하여, 주로 0 또는 1의 이진 출력을 생성합니다. 퍼셉트론은 선형적으로 구분 가능한 문제를 해결하는 데 사용됩니다.

### b. ReLU(Rectified Linear Unit) 활성화 함수의 특징과 장점에 대해 설명하시오.

**ReLU(Rectified Linear Unit)** 활성화 함수는 입력이 양수일 때는 그 값을 그대로 출력하고, 음수일 때는 0을 출력하는 함수입니다.

#### 특징:

- 입력 값이 0보다 크면 해당 값을 그대로 출력하고, 0 이하이면 0을 출력합니다.

#### 장점:

- **계산 효율성**: ReLU는 단순한 연산으로 인해 계산이 빠르고, 깊은 신경망에서의 학습 속도를 높여줍니다.
- **기울기 소실 문제 감소**: ReLU는 양수 영역에서의 기울기가 1로 유지되어, 역전파 시 기울기 소실(Vanishing Gradient) 문제를 완화시켜줍니다. 이로 인해 깊은 네트워크에서도 효과적인 학습이 가능합니다.

# A국 중앙은행은 다음과 같은 조건을 만족하는 B정보시스템의 구축을 계획하고 있다.

```plaintext
시스템 요구사항
■ 통계 및 이를 시각화한 결과물을 웹사이트를 통해 제공
■ 통계 생산을 위한 일부 기초 데이터는 개인정보 등을 포함하고 있어 보안에 유의가 필요
```

## A국 중앙은행 IT부서에서는 B정보시스템의 구현 방식에 대해 검토한 결과 최대한 클라우드를 활용하는 방향으로 추진하기로 하였다. 한편, 클라우드는 제공하는 서비스 수준에 따라 IaaS(Infrastructure as a Service), PaaS(Platform as a Service), SaaS(Software as a Service)로 구분할 수 있고, 배치 모델에 따라 프라이빗(private), 퍼블릭(public), 하이브리드(hybrid) 클라우드로 구분할 수 있다. 이에 대해 IT부서는 B정보시스템 구축 방안을 작성하고자 한다.

### 1. 클라우드를 사용하여 구축할 경우의 기대효과를 자체 서버를 사용하여 구축할 경우와 비교하고,

**비용 절감**: 클라우드를 사용하면 초기 하드웨어 및 인프라 구축 비용이 절감됩니다. 자체 서버를 구축할 경우, 하드웨어 구매, 설치, 유지보수에 대한 비용이 발생하지만, 클라우드는 사용한 만큼만 비용을 지불하는 방식이므로 더 경제적입니다.

**유연성 및 확장성**: 클라우드는 필요에 따라 자원을 쉽게 확장하거나 축소할 수 있어, 시스템의 규모에 따라 유연하게 대응할 수 있습니다. 자체 서버는 확장 시 추가 하드웨어가 필요하고, 축소 시에는 불필요한 자원이 남아 비효율적일 수 있습니다.

**운영 효율성**: 클라우드 서비스는 자동화된 관리 및 업데이트 기능을 제공하므로, IT 인프라 관리에 대한 부담이 줄어듭니다. 반면, 자체 서버는 모든 관리와 업데이트를 직접 수행해야 하므로 운영 부담이 큽니다.

**재해 복구 및 백업**: 클라우드 제공업체는 데이터 백업과 재해 복구 서비스를 제공하므로, 시스템 가용성과 데이터 보호가 향상됩니다. 자체 서버의 경우, 별도의 백업 시스템 구축과 관리가 필요합니다.

### 2. 클라우드 서비스 수준 및 배치 모델과 운 영효율성, 비용, 보안 등을 고려하여 B정보시스템의 구축 방안을 서술하시오.

**클라우드 서비스 수준**:

- **IaaS(Infrastructure as a Service)**: B정보시스템은 보안이 중요한 개인정보를 포함하고 있으므로, IT 부서가 인프라와 보안 설정을 직접 관리할 수 있는 IaaS가 적합합니다. IaaS는 서버, 스토리지, 네트워크를 가상화하여 제공하며, A국 중앙은행은 이를 활용하여 맞춤형 보안 정책을 적용할 수 있습니다.

**클라우드 배치 모델**:

- **하이브리드 클라우드**: 개인정보와 같은 민감한 데이터를 처리해야 하므로, 보안이 중요한 기초 데이터는 프라이빗 클라우드에서 관리하고, 통계 및 시각화된 결과물의 공개를 위해 퍼블릭 클라우드를 활용하는 하이브리드 클라우드 모델이 적합합니다. 이를 통해 민감 데이터의 보안을 강화하면서도, 공공 데이터의 효율적인 배포를 실현할 수 있습니다.

**운영 효율성 및 비용**:

- 하이브리드 클라우드를 사용하면 프라이빗 클라우드의 높은 보안성과 퍼블릭 클라우드의 비용 효율성을 모두 활용할 수 있습니다. 운영 효율성 측면에서 클라우드 서비스는 유지보수와 운영을 클라우드 제공업체가 담당하므로, IT 부서의 관리 부담이 줄어들고, 비용도 절감됩니다.

**보안**:

- 프라이빗 클라우드를 통해 민감 데이터를 안전하게 관리하며, 클라우드 제공업체의 최신 보안 기술과 규정을 활용할 수 있습니다. 퍼블릭 클라우드에서도 암호화, 접근 제어 등 보안 조치를 적용하여 데이터를 보호할 수 있습니다.

**결론**:

- B정보시스템은 보안과 운영 효율성을 고려하여, IaaS 기반의 하이브리드 클라우드 모델을 채택하는 것이 바람직합니다. 이를 통해 민감한 데이터를 안전하게 관리하면서도, 유연성과 비용 절감의 이점을 누릴 수 있습니다.
